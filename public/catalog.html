<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>NOXISTENCE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="icons/favicon.ico">
  <link rel="stylesheet" href="https://unpkg.com/lenis@1.3.4/dist/lenis.css">
  <style>
        /* Simple fade-in for page load */
        @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
        @font-face {
      font-family: 'Gobold';
      src: url('fonts/Gobold.otf');
      font-display: swap;
    }

    body {
      animation: fadeIn 0.1s ease-out;
      margin: 0;
      background: #ffffff;
      font-family: 'Gobold';
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 2rem;
      padding: 1rem;
      max-width: 1200px;
      width: 100%;
      margin: 2rem auto 1rem auto;
      flex: 1;
    }
    .creature-btn {
      appearance: none;
      -webkit-appearance: none;
      border: none;
      background: none;
      padding: 0;
      margin: 0;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      outline: none;
      box-shadow: none;
      width: 100%;
      transition: transform 0.2s ease, filter 0.2s ease;
      border-radius: 0px;
      padding: 8px;
    }
    .creature-btn:focus-visible img,
    .creature-btn:hover img {
      scale: 1.25;
    }
    .creature-btn:hover {
      transform: translateY(-3px);
      filter: brightness(1.05);
      background: rgba(255, 255, 255, 0.1);
    }
    .creature-btn:active {
      transform: translateY(0);
      filter: brightness(0.95);
    }
    .creature-btn:focus-visible {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }
    .creature-btn img {
      transition: transform 0.3s ease;
    }
    .creature-btn:hover img {
      transform: scale(1.05);
    }
    .creature-img {
      width: 100%;
      max-width: 11rem;
      aspect-ratio: 1/1;
      height: auto;
      object-fit: contain;
      border-radius: 8px;
      background: transparent;
      display: block;
      margin-bottom: 0.4rem;
      box-shadow: none;
    }
    .creature-name {
      font-weight: 500;
      font-size: 1.3rem;
      font-family: Gobold;
      color: #222;
      text-align: center;
      margin-bottom: 0;
      word-break: break-word;
      background: none;
      border: none;
      padding: 0;
    }
    .creature-world {
      display: none;
    }
    .no-results, .loading, .error {
      grid-column: 1 / -1;
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }
    
    .error {
      color: #d32f2f;
    }
    
    .creature-btn {
      transition: transform 0.2s;
    }
    
    .creature-btn:hover {
      transform: translateY(-2px);
    }
    .magic-title {
      animation: magicFade 4s ease-in-out infinite;
      text-align: center;
      position: relative;
      font-family: 'Gobold';
      font-size: 3rem;
      padding-top: 2rem;
      letter-spacing: 1rem;
      ;
    }
    @keyframes magicFade {
      0% { opacity: 1; }
      40% { opacity: 0.5; }
      60% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    @media (max-width: 700px) {
      .grid {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 1rem;
        padding: 0.5rem;
        max-width: 100vw;
        margin: 1rem 0;
      }
      .creature-img {
        max-width: 90vw;
      }
      .magic-title {
        font-size: 2rem;
        padding-top: 1rem;
      }
    }
        /* Estilos para la barra de desplazamiento */
        body::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    body::-webkit-scrollbar-thumb {
      background: transparent;
    }
    
    body::-webkit-scrollbar-track {
      background:transparent;
    }
  </style>
</head>
<body>
  <div id="header-container"></div>
  <div class="magic-title"><h4>CODEX NOX</h1></div>

  <div class="grid" id="creatureGrid"></div>
  <div id="footer-container"></div>
  <script src="https://unpkg.com/lenis@1.3.4/dist/lenis.min.js"></script>
  <script>
    // Inicializar Lenis para scroll suave
    const lenis = new Lenis({
      autoRaf: true
    });

    // Cargar el header
    fetch('header-catalogo.html')
      .then(r => r.text())
      .then(html => {
        document.getElementById('header-container').innerHTML = html;
        initCatalog();
      });

    function initCatalog() {
      const searchInput = document.getElementById('searchInput');
      const worldSelect = document.getElementById('worldSelect');
      const sheetSelect = document.getElementById('sheetSelect');
      const grid = document.getElementById('creatureGrid');
      let allCreatures = [];

      // Cargar criaturas y mundos únicos
      async function loadCreatures() {
        try {
          const res = await fetch('/api/creatures');
          allCreatures = await res.json();
          renderWorldOptions();
          renderCreatures();
        } catch (e) {
          allCreatures = [];
          renderCreatures();
        }
      }

      // Llenar el select de mundos únicos
      function renderWorldOptions() {
        const worlds = Array.from(new Set(allCreatures.map(c => c.world).filter(Boolean)));
        worldSelect.innerHTML = '<option value="">By Origin</option>';
        worlds.forEach(world => {
          const opt = document.createElement('option');
          opt.value = world;
          opt.textContent = world;
          worldSelect.appendChild(opt);
        });
      }

      // Renderizar lista de criaturas
      function renderCreatureList(creatures) {
        grid.innerHTML = '';
        
        if (creatures.length === 0) {
          grid.innerHTML = '<div class="no-results">No se encontraron criaturas.</div>';
          return;
        }
        
        for (const c of creatures) {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'creature-btn';
          btn.tabIndex = 0;
          
          // Agregar event listener para abrir el archivo HTML de la criatura
          btn.addEventListener('click', function() {
            openCreaturePage(c.name);
          });
          
          // También permitir abrir con Enter
          btn.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              openCreaturePage(c.name);
            }
          });
          
          const img = document.createElement('img');
          img.className = 'creature-img';
          img.src = c.img || '';
          img.alt = c.name || '';
          img.loading = 'lazy';
          btn.appendChild(img);
          
          const name = document.createElement('div');
          name.className = 'creature-name';
          name.textContent = c.name || '';
          btn.appendChild(name);
          
          if (c.world) {
            const world = document.createElement('div');
            world.className = 'creature-world';
            world.textContent = c.world;
            btn.appendChild(world);
          }
          
          grid.appendChild(btn);
        }
      }

      // Renderizar criaturas filtradas
      function renderCreatures() {
        const filterName = searchInput.value.trim().toLowerCase();
        const filterWorld = worldSelect.value;
        let creaturesToRender = allCreatures;
        
        // Aplicar filtros
        const filtered = creaturesToRender.filter(c => {
          const matchName = c.name && c.name.toLowerCase().includes(filterName);
          const matchWorld = !filterWorld || c.world === filterWorld;
          return matchName && matchWorld;
        });
        
        renderCreatureList(filtered);
      }

      // Función para abrir la página HTML de una criatura específica
      function openCreaturePage(creatureName) {
        if (!creatureName) {
          console.warn('Nombre de criatura no válido');
          alert('Error: Nombre de criatura no válido');
          return;
        }
        // Normalizar el nombre para usarlo como nombre de archivo
        const cleanName = creatureName
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '') // Remover caracteres especiales
          .replace(/\s+/g, '-') // Reemplazar espacios con guiones
          .replace(/-+/g, '-') // Remover guiones múltiples
          .trim();
        const url = `viewer.html?file=creatures/${encodeURIComponent(cleanName)}.json`;
        window.location.href = url;
      }

      // Llenar el select de colecciones/hojas
      async function loadSheets() {
        try {
          const res = await fetch('data/catalog.json');
          const files = await res.json();
          
          // Add default option
          const defaultOpt = document.createElement('option');
          defaultOpt.value = '';
          defaultOpt.textContent = 'All Collections';
          sheetSelect.appendChild(defaultOpt);
          
          // Add collections
          files.forEach(file => {
            const opt = document.createElement('option');
            opt.value = file;
            opt.textContent = file.replace('.json', '');
            sheetSelect.appendChild(opt);
          });
        } catch (e) {
          console.error('Error loading collections:', e);
        }
      }

      // Eventos de filtrado
      searchInput.addEventListener('input', renderCreatures);
      worldSelect.addEventListener('change', renderCreatures);

      // Función para normalizar nombres (quitar espacios, convertir a minúsculas, etc.)
      function normalizeName(name) {
        return name ? name.toString().trim().toLowerCase().replace(/\s+/g, ' ') : '';
      }

      // Evento para filtrar por colección
      sheetSelect.addEventListener('change', async function() {
        const selectedFile = this.value;
        
        if (!selectedFile) {
          // Si se selecciona "All Collections", mostrar todas las criaturas
          renderCreatures();
          return;
        }
        
        try {
          // Mostrar estado de carga
          grid.innerHTML = '<div class="loading">Cargando colección...</div>';
          
          // Cargar la colección seleccionada
          const res = await fetch(`hojas/${selectedFile}`);
          const collectionData = await res.json();
          
          // Extraer nombres de criaturas de la colección
          const creatureNames = new Set();
          
          // Buscar en arrays de imágenes
          if (collectionData.images) {
            collectionData.images.forEach(img => {
              if (img.name) {
                // Agregar el nombre normalizado al conjunto
                creatureNames.add(normalizeName(img.name));
              }
            });
          }
          
          // Buscar en arrays de arte
          if (collectionData.artimages) {
            collectionData.artimages.forEach(art => {
              if (art.name) {
                // Agregar el nombre normalizado al conjunto
                creatureNames.add(normalizeName(art.name));
              }
            });
          }
          
          console.log('Nombres de criaturas en la colección:', Array.from(creatureNames));
          console.log('Total de criaturas cargadas:', allCreatures.length);
          
          // Filtrar criaturas para mostrar solo las de esta colección
          const filteredCreatures = allCreatures.filter(creature => {
            const normalizedCreatureName = normalizeName(creature.name);
            const isInCollection = creatureNames.has(normalizedCreatureName);
            console.log(`Comprobando ${creature.name} (${normalizedCreatureName}): ${isInCollection}`);
            return isInCollection;
          });
          
          console.log('Criaturas filtradas:', filteredCreatures);
          
          // Aplicar filtros actuales (búsqueda y mundo)
          const filterName = searchInput.value.trim().toLowerCase();
          const filterWorld = worldSelect.value;
          
          const filtered = filteredCreatures.filter(c => {
            const matchName = c.name && c.name.toLowerCase().includes(filterName);
            const matchWorld = !filterWorld || c.world === filterWorld;
            return matchName && matchWorld;
          });
          
          // Mostrar la lista filtrada
          if (filtered.length === 0) {
            grid.innerHTML = `
              <div class="no-results">
                No se encontraron criaturas en esta colección.<br>
                <small>Nombres en la colección: ${Array.from(creatureNames).join(', ')}</small>
              </div>`;
          } else {
            renderCreatureList(filtered);
          }
        } catch (error) {
          console.error('Error al cargar la colección:', error);
          grid.innerHTML = `
            <div class="error">
              Error al cargar la colección: ${error.message}
              ${error.stack ? `<pre>${error.stack}</pre>` : ''}
            </div>`;
        }
      });

      // Inicializar
      loadCreatures();
      loadSheets();
    }

    fetch('footer.html')
      .then(r => r.text())
      .then(html => { document.getElementById('footer-container').innerHTML = html; });
  </script>
</body>
</html>
